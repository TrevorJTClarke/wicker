<!DOCTYPE HTML>
<html>
<head>
<title>Wicker - Tiny Canvas Engine</title>
<style> body { margin: 0px; padding: 80px; } canvas { margin: 0 auto; display: block;} </style>
</head>
<body>
<script>
window.requestAnimFrame = (function(callback) {
  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
  function(callback) {
    window.setTimeout(callback, 1000 / 60);
  };
})();

/**
 * Wicker
 *
 * Useful for creating canvas instances
 */
var Wicker = function () {

  // Only stores the current instance
  this.instance = null;

  /**
   * builds a new canvas element, with specified options
   * @param  {Object} options any items to add to the canvas
   * @return {Object}         returns newly created canvas
   */
  this.new = function(options, parent) {
    var cv = document.createElement('canvas');

    // apply options quickly, #noRegretsNoChecks
    if (options) {
      for (var key in options) {
        cv[key] = options[key];
      }
    }

    // Store for later internal use
    this.instance = cv;

    if (parent && parent.appendChild) {
      parent.appendChild(cv);
    } else {
      document.body.appendChild(cv);
    }

    if (!options) {
      this.fitToParent();
    }

    return this;
  };

  this.createRect = function(options) {
    var rect = this.instance.getContext('2d');

    rect.beginPath();
    rect.rect(options.position.x, options.position.y, options.position.w, options.position.h);
    rect.fillStyle = options.background || '#FFF';
    rect.fill();

    return this;
  };

  this.fitToParent = function() {
    // Make it visually fill the positioned parent
    this.instance.style.width ='100%';
    this.instance.style.height='100%';
    // ...then set the internal size to match
    this.instance.width  = this.instance.offsetWidth;
    this.instance.height = this.instance.offsetHeight;
  };

  return this;
};



// Fun Example
(function() {

// surreal logic, #seeWhatIDidThere
var W = new Wicker();
// var main = {
//   w: window.innerWidth, //
//   h: window.innerHeight //
// };
var main = {
  w: 250,
  h: 205
};

var container = W.new({ width: main.w, height: main.h });
var size = 3;
var offset = 200;

var canvas = document.querySelector('canvas');
var context = canvas.getContext('2d');
var rectWidth = main.w - 12;
var rectHeight = main.h - 8;
var rectX = 5;
var rectY = 5;
var cornerRadius = 5;
var previousData;

function rand(bottom, top) {
  if (bottom === 0 && top === 0) {return 0;}
  top = top || 10;
  bottom = bottom || 1;
  return (Math.floor(Math.random() * 10) + bottom) / top;
}

function getColor(isFirst, bottom, top) {
  var h = rand(bottom, top);

  if (!isFirst) {
    if (rand() % rand() / 4 == 0) {
      return "rgba(255, 0, 255, " + Math.max(Math.min(h - 0.3, 0.9), 0.1) + ")";
    } else {
      return "rgba(160, 160, 160, " + Math.max(Math.min(h - 0.3, 0.4), 0) + ")";
    }
  } else {
    return "rgba(200, 200, 200, " + h + ")";
  }
}


var totalRows = Math.round(main.h / size);
var totalCols = Math.round(main.w / size);

// Dont follow this logic, just believe :)
function getRandomData(isFirst) {
  var dataSet = [];
  var cluster = [];
  var clusterTotal = (isFirst) ? Math.round(totalRows) : Math.round(totalCols);

  // setup clumper
  for (var i = 0; i < clusterTotal; i++) {
    if (i < 1 || i > clusterTotal - 1) {
      cluster.push(0);
    } else {
      if (i % 3 === 0) {
        cluster.push(0);
      } else {
        cluster.push(rand(i % 2) * 10);
      }
    }
  }

  var cl = 0;
  var horizOffset = Math.floor(Math.random() * 77) + 78;
  var vertOffset = Math.floor(Math.random() * 17) + 18;

  for (var r = 0; r <= totalRows; r++) {
    horizOffset = (f % vertOffset === 0 && f > 25) ? Math.floor(Math.random() * 13) + 15 : horizOffset;
    vertOffset = (f % vertOffset === 0 && f > 7) ? Math.floor(Math.random() * 12) + 13 : vertOffset;

    for (var c = 0; c <= totalCols; c++) {
      var f = (isFirst) ? r : c;
      var s = (isFirst) ? c : r;
      var gate, clr;
      cl = (cl >= cluster.length - 1) ? 0 : cl;
      cl++;

      if (isFirst) {
        if (f % vertOffset === 0 || (f - 1) % vertOffset === 0 || (f + 1) % vertOffset === 0 && s % horizOffset !== 0 && f > 6) {
          clr = getColor(true, 0, 0);
        } else if (s % horizOffset === 0 || (s - 1) % horizOffset === 0 && f > 6) {
          clr = getColor(true, 0, 0);
        } else if (s < 6 || s > totalCols || f === 6 || f === 7) {
          clr = getColor(true, 0, 0);
        } else {
          gate = cluster[cl];
          clr = getColor(isFirst, gate, Math.max(gate + 2, 10));
        }
      } else {
        if ( previousData ) {
          var tmpPrevItem = (previousData && previousData[s] && previousData[s][f][0]) ? previousData[s][f][0].split(",")[3].trim().replace(')', '') : null; //.split(',')[2]
          tmpPrevItem = parseFloat(tmpPrevItem, 10);

          if (tmpPrevItem === 0 || tmpPrevItem === NaN) {
            clr = getColor(true, 0, 0);
          } else {
            var low = rand();
            var high = rand(low, low + 5);
            if (f > 6 && ((s % horizOffset < high && s % horizOffset > low) || (s - 1 % horizOffset < high && s - 1 % horizOffset > low) || (s - 2 % horizOffset < high && s - 2 % horizOffset > low))) { //f % vertOffset === 0 || (f - 1) % vertOffset === 0 || (f + 1) % vertOffset === 0 && s % horizOffset !== 0 &&
              clr = "rgba(255, 0, 255, " + Math.max(Math.min(rand(), 0.6), -0.9) + ")";
            } else if (s % horizOffset === 0 || (s - 1) % horizOffset === 0 && f > 6) {
              clr = getColor(true, 0, 0);
            } else {
              gate = cluster[cl];
              clr = getColor(isFirst, gate, Math.max(gate + 3, 10));
            }
          }
        }
      }

      dataSet[f] = dataSet[f] || [];
      dataSet[f][s] = dataSet[f][s] || [];
      dataSet[f][s].push(clr);
    }
  }

  return dataSet;
}

function drawSet(data, current, isFirst) {
  var total = data.length;

  for (var row = 0; row < total; row++){
    var x = (isFirst) ? row * size : current * size;
    var y = (isFirst) ? current * size : row * size;
    var compare = (isFirst) ? (x < main.w - 10 && y < main.h - 32) : (x < main.w - 44 && y < main.h - 32);

    if (compare) {
      container.createRect({
        position: { x: x + 11, y: y + 25, w: size, h: size },
        background: data[current][row]
      });
    }
  }
}


// testing
var inc = 0;
var inc2 = 0;
var test = getRandomData(true);
previousData = test;
var test2 = getRandomData(false);

function animate2() {
  var timey = setTimeout(function() {
    var total = (inc2 === 0) ? totalRows : totalCols;
    if (inc >= total) {
      if (inc2 === 0) {
        inc2 = 1;
        inc = 0;
      } else {
        window.clearTimeout(timey);
        return;
      }
    }

    requestAnimFrame(function() {
      if (inc2 === 1) {
        drawSet(test2, inc, false);
      } else {
        drawSet(test, inc, true);
      }
      inc++;
      animate2();
    });
  }, 5); // potential offset
}
animate2();

context.beginPath();
context.strokeStyle = 'rgb(160, 160, 160)';
context.moveTo(rectX + cornerRadius, rectY);
context.lineTo(rectX + rectWidth - cornerRadius, rectY);
context.arcTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + cornerRadius, cornerRadius);
context.lineTo(rectX + rectWidth, rectY + rectHeight - cornerRadius);
context.arcTo(rectX + rectWidth, rectY + rectHeight, rectX + rectWidth - cornerRadius, rectY + rectHeight, cornerRadius);
context.lineTo(rectX + cornerRadius, rectY + rectHeight);
context.arcTo(rectX, rectY + rectHeight, rectX, rectY + rectHeight - cornerRadius, cornerRadius);
context.lineTo(rectX, rectY + cornerRadius);
context.arcTo(rectX, rectY, rectX + cornerRadius, rectY, cornerRadius);
context.lineWidth = 5;
context.stroke();
container.createRect({
  position: { x: rectX, y: rectY, w: rectWidth, h: 20 },
  background: "rgb(160, 160, 160)"
});
container.createRect({
  position: { x: rectWidth * 0.40, y: rectY + 5, w: rectWidth * 0.60, h: 10 },
  background: "white"
});

context.beginPath();
context.arc(rectX + 10, rectY + 10, 4, 0, 2 * Math.PI, false);
context.fillStyle = 'white';
context.fill();
context.beginPath();
context.arc(rectX + 22, rectY + 10, 4, 0, 2 * Math.PI, false);
context.fillStyle = 'white';
context.fill();
context.beginPath();
context.arc(rectX + 34, rectY + 10, 4, 0, 2 * Math.PI, false);
context.fillStyle = 'white';
context.fill();


})();
</script>
</body>
</html>
